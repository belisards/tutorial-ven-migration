[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Venezuelan Migrants and Refugees in Chile, Colombia, Ecuador, and Peru",
    "section": "",
    "text": "This tutorial aims to help analysts and local policymakers develop evidence-based policies and promote a mutually beneficial relationship between Venezuelan migrants and their host communities in Chile, Colombia, Peru, and Ecuador. It presents an overview of open-source technologies to analyze survey data and introduces a step-by-step guide to use R to describe statistics from host populations and Venezuelan migrants."
  },
  {
    "objectID": "index.html#preliminary-analysis",
    "href": "index.html#preliminary-analysis",
    "title": "Venezuelan Migrants and Refugees in Chile, Colombia, Ecuador, and Peru",
    "section": "Preliminary analysis",
    "text": "Preliminary analysis\nTo understand how each country file is structured, let’s review some core variables. You can find detailed descriptions for all available variables in the data dictionaries (codebooks).\n\nsurvey: the name of the survey;\nwave: the wave of the survey. Surveys might have more than one round, known as waves. Each wave is collected in a distinct period of time.\nsamp: indicate whether the response comes from Venezuelan or the host population;\nweight: the weight assigned for each record to produce unbiases estimates;\n\nEach file aggregates different surveys from the same country. Therefore, you should use the variables survey and wave to filter the data and pick the right source depending on your research question. Because distinct surveys cover different questions, some rows have missing values.\n\nInspect missing values\nLet’s plot the missing values for each of the surveys available. The chart shows more records from the EPEC survey than HFPS. The highlighted regions make it easy to spot which variables have missing values.\nThe vis_miss() function is part of the visdat package in R. It is used to visualize missing data in a dataset and, below, takes the dataset named survey as the first parameter and a column to group (facet) the observations by.\n\nvisdat::vis_miss(survey,facet = survey)\n\n\n\n\nTo keep it simple, our tutorial analyses only information on age, marital status, region, and population type (host or Venezuelan migrant) in the HPFS survey. As the image shows, these variables have no missing values, so we will not worry about missing values. Nevertheless, handling missing values is crucial to the data preparation phase. You might need to drop missing values or impute values to conduct other analyses. Your chosen strategy depends on why values are missing, the number of missing values, and your analytical goals. Please refer to the data dictionary and documentation to understand the reasons for missing values.\n\n\nRecords by surveys and waves\nBefore applying the weights, we will check the total number of respondents by survey, wave and population.\nAs the name suggests, the group_by function is used for grouping data by one or more variables. Using this command doesn’t actually change the dataset; rather, it sets up a new configuration for subsequent operations within each group. The summarise function is used to compute summary statistics or metrics for each group. Finally, the kable() function presents the result well-structured, better than the standard output.\n\nsummary_df <- survey %>% \n  group_by(survey, wave, samp) %>% \n  summarise(total = n(), .groups = 'drop')\n\n# Output the table\nkable(summary_df, caption = \"Number of records by survey, wave and population\")\n\n\nNumber of records by survey, wave and population\n\n\nsurvey\nwave\nsamp\ntotal\n\n\n\n\nEPEC\n1\nHosts\n1807\n\n\nEPEC\n1\nMigrants\n1256\n\n\nHFPS\n2\nHosts\n503\n\n\nHFPS\n2\nMigrants\n356\n\n\n\n\n\nKeep in mind these values reflect the number of responses from an unweighted sample of Venezuelan migrants and host population, not the actual migrant and local population. Next, we’ll demonstrate how to use weights to calculate more representative estimates."
  },
  {
    "objectID": "index.html#configure-the-survey-design",
    "href": "index.html#configure-the-survey-design",
    "title": "Venezuelan Migrants and Refugees in Chile, Colombia, Ecuador, and Peru",
    "section": "Configure the survey design",
    "text": "Configure the survey design\nAs different surveys present distinct questions, you should select the survey according to the goals of your analysis. For instance, the data for Ecuador relies on the High-Frequency Phone Survey (HFPS) and the 2019 Human Mobility and Host Communities Survey (EPEC, for its acronym in Spanish). Most of the indicators used in the report come from the HFPS, except those referring to job occupations and health insurance, which come from the EPEC survey.\nWe will select the HFPS survey to calculate and compare the average age of Venezuelan migrants and the host population in Ecuador. Let’s start filtering the dataset to get only observations from the HFPS using the filter() function.\n\nsurvey_filter <- survey %>% \n  filter(survey == \"HFPS\")\n\nNext, we load the survey design and the weights associated with each response. There are a variety of ways to implement weighted data analysis using R. For convenience, we use the function svydesign from survey, an R package with pre-built features tailored for survey analysis. It allows for the specification of survey design parameters such as sampling weights, strata, and clusters.\n\nsurvey_ecu <- svydesign(ids = ~1, # ~1 means the survey has no clusters\n                       data= survey_filter, \n                       weights = survey_filter$weight)\n\nNow, we are ready to produce more accurate estimates about the populations of interest."
  },
  {
    "objectID": "index.html#descriptive-statistic",
    "href": "index.html#descriptive-statistic",
    "title": "Venezuelan Migrants and Refugees in Chile, Colombia, Ecuador, and Peru",
    "section": "Descriptive statistic",
    "text": "Descriptive statistic\nCreating basic summary statistics using the survey package is straightforward. Our tutorial shows how to group observations and analyze numeric and categorical variables. If you group by region (the column code_province), bear in mind that the weights are not meant for this level of disaggregation, and the estimates may not accurately reflect the characteristics of these populations in each region, resulting in biased estimates.\n\nNumeric values\nThe svyby function is used to apply a function to subsets of survey data defined by one or more variables. We will use it to group the records by the population type (~samp) and calculate the mean age (svymean).\nThe output shows the mean and the standard error (se) for each estimate. Standard error values use the same unit of measurement as the mean. They represent how much the sample mean calculated is expected to vary from the actual population mean.\n\n# Group by and calculate the mean age\nsvyby(formula = ~age, by = ~samp, design = survey_ecu, svymean)\n\n             samp      age        se\nHosts       Hosts 39.88760 0.9410057\nMigrants Migrants 36.09989 0.5309258\n\n\n\n\nCategoric variables\nThe svytable function is used to create contingency tables for survey data, taking into account survey design features such as sampling weights. Next, we use it to analyze marital status.\nUsing prop.table(crosstab, 1), we present the values as percentages of the population/row level (using 0 instead of 1 in the command would sum the values to 100 across columns). Additionally, we round the values to two decimal places with round().\n\n# Cross-tabulates values\ncrosstab <- svytable(~samp + marital_status, design = survey_ecu)\n\n# Calculate percentages\ncrosstab_percentages <- round(prop.table(crosstab,1) * 100,2) \n \n# Output the table\nknitr::kable(crosstab_percentages, \n             caption = \"Crosstab of Occupation by Marital Status (%)\")\n\n\nCrosstab of Occupation by Marital Status (%)\n\n\n\nMarried/Cohabitation\nOther\nSingle\n\n\n\n\nHosts\n54.32\n10.64\n35.04\n\n\nMigrants\n51.14\n4.29\n44.57"
  }
]